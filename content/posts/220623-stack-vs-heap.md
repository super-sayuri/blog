---
title: "堆和栈到底指什么"
date: 2022-06-23T15:54:21+08:00
tags: ["heap", "stack", "内存"]
categories: ["编程"]
---

## 程序是如何在内存中分配
当启动一个程序时间，操作系统会给它分配一段连续的内存。这些内存只是在逻辑上连续而非在物理上连续，但是并不影响我们画图示。最开始的地方会储存程序的机器码，也就是编译完成之后机器可以识别并运行的代码，之后会有一段地方来储存程序的全局变量或环境变量。内存的大头是堆和栈，其中栈用于储存函数的信息属于而堆用于储存变量的信息。此外还有额外的一些系统变量。我们画个图大概长这样：

![内存图](/blog/img/220623/1.png)

顺便说以下，虽然各个操作系统和不同语言写的程序在细节上有些微小的差别，例如堆和栈的位置，是否有专门的内存存储全局变量。但是其大致的架构是类似的，这个抽象模型并不影响我们去理解不同语言对于内存的操作。

## 栈 Stack
我一直觉得Stack翻译成栈增加了理解成本。Stack的意思是一叠，大概想象成很多书叠在一起的样子。数据结构中的Stack就指这样的一个结构，你要存的东西放在这一叠东西的最上面，要度的东西就从这叠东西的最上面那出来一个。

我们知道内存里堆存放的是函数信息，是怎么存放的呢？其实和数据结构中的栈一样，一个新的函数进来了，就将其放到栈的最上面，函数运行完成了它一定在最上面，所以就把它抽走就可以了。

很多小朋友这个时候就会说：不对呀，现在线程1起了一个函数放到栈里，线程2也起了一个函数，当线程2的函数还没运行好的时候线程1的函数运行完了，那么它不就不再最上面了吗？

很好的问题，对于这个问题的解决也很简单，我们只需要将每个线程都弄一个单独的堆就可以了。

接着就是看看堆上的每块内存里存的是什么东西了。一般来说一个函数会有这些内容：
* 函数本身
* 函数的参数
* 函数里面的变量
* 函数返回值


例如下面的代码(rust)
```rust
fn main() {
    let a = 10;
    let b = add_one(a);
    println!("{}", b)
}
fn add_one(i: i32) -> i32 {
    i+1
}
```
首先开始`main()`函数入栈，里面会有a和b，在b调用函数`add_one`时，这个函数入栈，其中参数`i`和返回值都会单独分配内存。等这个函数结束之后销毁`add_one`的内存，将返回值赋到b上，最后再完成销毁`main`函数的内存。

画张图可以这样理解：

![](/blog/img/220623/2.png)

值得注意的是，参数，变量和返回值一般都是分配在不同的内存上，所以在修改一处的时候另一处并不会修改，下面的代码(go)可以说明这个情况:
```go
func See() {
    a := 1 // 这里的a在See函数的栈上
    changeA(a) // 这里会把a的值复制给changeA里面的a
    fmt.Println(a) // 1
    b := getB1(a)
    fmt.Println(b) // 2
    b = getB2(a)
    fmt.Println(b) // 3
}

func changeA(a int) { // 这里a在changeA的参数栈上，和See里面的a没有任何关系
    a = a + 1
    fmt.Println(a) // 2
}

func getB1(a int) int {
    b := a + 1 // 这里b会在getB1的变量里
    defer func() {
        b = b + 1
    }()
    return b // 这里会复制b的值到返回值内存上，而后面的defer改变的是变量b的值，因此最后返回的值不会变
}

func getB2(a int) (b: int) {
    b = a + 1 // 这个b就是返回值的内存
    defer func() {
        b = b + 1 // 因为b是返回值的内存，所以这里会改变最后返回的值
    }()
    return b
}
```

## 值与引用

很多小朋友会说不对呀，为什么我很多时候我在函数里改参数的时候，即使退出了这个函数，值也变化了呢？例如这样(java):

```java
void foo() {
    int[] a = {1, 2, 3};
    System.out.println(a[0]); // 1
    changeA(a);
    System.out.println(a[0]); // 10
}

void changeA(int[] a) {
    a[0] = 10;
}
```

很好，简单的回答一下：上面的a是引用而不是一个值。

那么什么是值什么是引用呢？简单的来说，就是一个指向对象内存地址的指针。例如go, rust前面带&的都是一个引用，而java里所有的object都是引用。

既然是指向内存地址的指针，那么它指向哪里呢？答案是堆上的数据。

由于栈的大小有限，对于很多很复杂的数据结构，例如数组、map、string 以及自定义的类，这些根本不会在栈里存放完整的数据，而一般是在堆里分配一个数据，之后将其地址储存到栈上。这样，可以有效减少栈的空间。而正因为使用了引用，所以在改变值的时候改变的是堆里数据的值，这个值并不会随着栈的回收而变动，所以对于引用对象的改变自然会反映到值上面。

不过值的注意的是，上面函数两个a引用值的栈上内存还是不同，所以当改变`changA`里面a的值并不会反映到`foo`中a的值，例如：

```java
void foo() {
    int[] a = {1, 2, 3};
    System.out.println(a[0]); // 1
    changeA(a);
    System.out.println(a[0]); // 1
}

void changeA(int[] a) {
    a = {10, 11, 12}; //这里a分配了新的内存地址，也就是a指针指向的目标改变了，自如不会改变foo中的a
}
```

## 堆 Heap

我们现在知道所有的复杂类型都是在堆里分配，知道了这些就能很容易理解很多东西。

### 切片 slice
go 和 rust 中，数组（array）是定长的，虽然它们也是分配在堆上面，但是它们的传递是值，也就是会进行一个复制，例（go）：

```go
func main() {
	var a [1]int
	a[0] = 1
	fmt.Println(a[0]) // 1
	aarrss(a)
	fmt.Println(a[0]) // 还是1
}

func aarrss(arr [0]int) {
	arr[0] = 10
}
```

切片则不一样，切片有三个主要元素：
1. 一个指向数组的指针
2. len，切片的长度
3. cap，容量，可以理解为数组的长度，每当切片的长度大于容量的时候就需要扩容了

所以在改变切片内元素的时候，其实改变的是切片所指向数组的元素，然而切片内指向数组指针不变，所以其数值也会发生变化：

```go
func main() {
	a := make([]int, 1)
	a[0] = 1
	fmt.Println(a[0]) // 1
	aarrss(a)
	fmt.Println(a[0]) // 变了10了哦
}

func aarrss(arr []int) {
	arr[0] = 10
}
```

### rust 中的智能指针
* Box，可以直接理解为返回对象在堆上的地址
* Rc，加了一个引用的计数器，当计数器变为0的时候会直接把对象内存释放
* Arc，线程安全版的Rc

### 垃圾收集
现在写得爽的语言多半都带点垃圾收集，虽然有点性能问题，但是大大提高了开发速度。(虽然一般情况下那种代码质量也达不到性能瓶颈)

由于栈上的数据都是随着函数的进入和退出而分配和回收的，所以不存在垃圾收集的问题，所以垃圾回收都在堆上。

垃圾回收的本质都是找到没有引用的元素然后把内存释放，无论是go的三色标记还是java的新生代老生代本质上都是一种找到垃圾未引用空间的算法。