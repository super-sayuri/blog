---
title: "什么是lambda λ"
date: 2022-07-05T18:05:20+08:00
tags: ["λ", "函数式编程", "lambda"]
categories: ["编程"]
---

## 程序的本质和图灵完备

我们现在的计算机最开始是英国人破译德军密码和美国人为了计算导弹而被设计出来的，它计算起来比人要快多了。运算包括输入的数据，运算的方法和输出的数据。所谓的程序就是一系列运算序列打个包，你只需要输入数据它就自动给你输出。程序的本质就是换着各种姿势给你计算。

那么就延伸出来一个问题：什么是程序能解决的，什么是程序不能解决的？

这里引入一个图灵机的概念。图灵机其实并不是一种机器，而是图灵提出来的一种抽象概念，图灵机包括：

1. 一条无限长的纸带，纸带分成小格子，每个格子上只能在一个有限集的字符里选一个字符打印
2. 有一个指针能任意在纸带上移动并读写纸带上的内容
3. 一个寄存器来记录图灵机当前的状态，这个状态是有限的，并且有一个特殊状态使图灵机停机
4. 一套规则告诉指针在读到每个符号之后做什么，这其中包括读写当前值、移动和改变寄存器的值

任何能够抽象成一个图灵机的东西就是图灵完备的。说得再具体一点，由于我们所用的各类主流程序语言都是图灵完备的，也就是所有能编成主流程序语言的东西都是图灵完备的。极端点的 Brainfuck 语言就直接把图灵机写到脸上了。除了各类程序语言，像是生命游戏、细胞自动机等和程序无关的东西也都是图灵完备的。

所有图灵机能解决的问题都是程序能解决的，虽然说图灵完备和可计算性有一点差别，不过这里可以忽略不计。

## λ演算（λ calculus）是什么？

言归正传，λ calculus ，也就是我们常说的 lambda 就是图灵完备的。也就是λ是通过某种方法来实现我们现在其他语言写的所有功能。

那么什么是 lambda呢？

### 如何构建 lambda

1. 一个变量 x 是 lambda
2. 一个完整的函数定义 λx.M 是 lambda， 其中 M 是一個 lambda 项，其中的 x 都会绑定为变量 x
3. 一个函数的应用 M N 是 lambda，当然 M 和 N 都是lambda项。

以上三个规则构建出来的就是一个 lambda，例如：λx.λy.(λz.(λx.zx)(λy.zy))(x y)，一个 lambda中如果括号删去没有歧义，则可以省略。

### α-变换 和 β-归约

这两条是 lambda 的基础运算规则

α-变换指的是 lambda λx.M[x] 中，所有 x 可以换成其他字符y，最后变为 λy.M[y]。例如 λx.xy 和 λa.ay 是完全一样的式子

β-归约的意思是 lambda λx.M E 中，x 可以替换成 E，变成式子 M[x:=E]。例如 λx.λy.x λa.a 就可以变为 λy.λa.a

## 开始用 lambda 写算法吧

好了，你现在已经知道所有 lambda 的基础了，介于 lambda 是图灵完备的，试着用它写程序吧。

### 数字与加减乘除

首先，自然数是这样的：

- 有一个元数0
- 每个自然数 n 都有一个后继 n'，并且0不是任何自然数的后继
- 如果 a 的后继 a' 和 b 的后继 b' 相等，那么 a 和 b 也相等

根据这套规则，我们现用 lambda 构建数字0：

```
0 = λf.λx.x
```

同时定义后继函数：

```
SUCC = λn.λf.λx.f(n f x)
```

很自然，我们可以算出0的后继0'，即1：

```
1 = SUCC 0 = λn.λf.λx.f(n f x) λf.λx.x = λf.λx.f(λf.λx.x f x) = λf.λx.f(x) = λf.λx.f x
```

继而可以计算出2、3等等等等：

```
2 = λf.λx.f (f x)
3 = λf.λx.f (f (f x))
...
```

（以上所算出来的数字叫做丘奇数`Church encoding`）

之后可以定义减法、乘法和指数：

```
ADD = λm.λn.λf.λx.m f (n f x)
MUL = λm.λn.λf.n (m f)
EXP = λm.λn.n m
```

减法和除法、取余虽然也可以定义，但是由于其在自然数上不是完备的，所以这里就写了，有兴趣可以自己去找以下。

### 布尔值和条件

和上面的方法一样，先定义 TRUE 和 FALSE

```
TRUE = λa.λb.a
FALSE = λa.λb.b
```

我们可以简单理解 TRUE 就是两个参数选第一个， FALSE 就是两个参数选后一个。很多小朋友可能发现了，FALSE 的写法根据 α-变换可以编成数字0，没错，FALSE 和数字0就是一个东西。

之后是布尔运算：

```
AND = λp.λq.p q p
OR = λp.λq.p p q
NOT = λp.p FALSE TRUE
```

最后还有一个比较重要的，就是条件选择语句 IFTHENELSE，可以理解为c语言的 `:?` 运算符。

```
IFTHENELSE = λp.λa.λb.p a b
```

### 递归

虽然说表面上 lambda 不能递归，其实不然，看看这个：

```
λx.x x λx.x x
```

以上这个式子运算一遍就会发现得到的结果就是它本身，我们再看另一个例子：

```
Y = λg.(λx.g(x x)) (λx.g(x x))
```

当我们把g本身作为参数传进去的时候就会发现：

```
Y g = λh.(λx.h(x x)) (λx.g(x x)) g
= λx.g(x x) λx.g(x x)
= g(λx.g(x x) λx.g(x x))
= g (Y g)
```

可以看到，调用g的结果等于g调用了自身。

## 所以说λ有什么用？

从上面我们可以看出，lambda 拥有了位运算、条件判断、递归循环这三个特性，也就是现在所有的程序都可以用 lambda 重写。事实上，lisp 作为一个以 lambda 为基础的语言在1958年就已经发明出来，仅次与 fortan。同时，python, javascript, ruby 等高级的语言也吸收了 lambda 的特性，更别提 haskell, scala 这样的纯函数语言。

lambda 为基础的函数式编程在处理大数据、高并法下是很有优势的。很多语言的优化中都提到如果可以使用 lambda， 那么最好都使用 lambda。了解 lambda 最起码能让你看懂更多的代码。

对了，下一期会说一下函数式编程里面的各种奇怪的方法是干什么的。
